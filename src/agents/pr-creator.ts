import { exec } from 'child_process';
import { promisify } from 'util';
import { AgentContext, ConversationMessage } from '../types/index.js';
import { sessionService } from '../services/session.js';
import { githubService } from '../services/github.js';
import { Octokit } from '@octokit/rest';

const execAsync = promisify(exec);

export async function runPRCreator(context: AgentContext): Promise<{ prNumber: number; prUrl: string } | null> {
  const { session, payload } = context;
  const { source_repo, issue_number } = payload;

  if (!issue_number) throw new Error('Missing issue_number');

  const repoPath = process.env.REPO_PATH || process.env.GITHUB_WORKSPACE || './source-repo';
  const githubToken = process.env.GITHUB_TOKEN;
  
  if (!githubToken) throw new Error('Missing GITHUB_TOKEN');

  console.log(`Creating PR for ${source_repo}#${issue_number}`);

  await githubService.postComment(
    source_repo,
    issue_number,
    `ðŸš€ **Creating Pull Request**\n\nPreparing to open a PR with the implementation...`
  );

  const [owner, repo] = source_repo.split('/');
  const branchName = `agent/issue-${issue_number}`;
  const octokit = new Octokit({ auth: githubToken });

  try {
    // Configure git
    await execAsync('git config user.email "agent@cherry-automation.dev"', { cwd: repoPath });
    await execAsync('git config user.name "Cherry Agent"', { cwd: repoPath });

    // Check for changes
    const { stdout: statusOutput } = await execAsync('git status --porcelain', { cwd: repoPath });
    
    if (!statusOutput.trim()) {
      await githubService.postComment(
        source_repo,
        issue_number,
        `âš ï¸ **No Changes Detected**\n\nThere are no file changes to commit. The implementation may not have made any modifications.`
      );
      return null;
    }

    // Create and checkout branch
    console.log(`Creating branch: ${branchName}`);
    try {
      await execAsync(`git checkout -b ${branchName}`, { cwd: repoPath });
    } catch {
      // Branch might exist, try to checkout
      await execAsync(`git checkout ${branchName}`, { cwd: repoPath });
    }

    // Stage all changes
    await execAsync('git add -A', { cwd: repoPath });

    // Create commit message
    const commitTitle = session.metadata.issue_title || `Fix issue #${issue_number}`;
    const commitBody = `Automated implementation for #${issue_number}

## Changes Made
${(session.metadata.implementedFiles as string[] || []).map((f: string) => `- ${f}`).join('\n') || 'See diff for details'}

## Implementation Notes
This PR was automatically generated by Cherry Agent based on:
- Clarified requirements
- Defined scope
- Technical design
- Implementation plan

ðŸ¤– Generated by Cherry Automation`;

    // Commit
    await execAsync(`git commit -m "${commitTitle}" -m "${commitBody.replace(/"/g, '\\"')}"`, { cwd: repoPath });

    // Push (need to set remote URL with token for auth)
    const remoteUrl = `https://x-access-token:${githubToken}@github.com/${source_repo}.git`;
    await execAsync(`git remote set-url origin ${remoteUrl}`, { cwd: repoPath });
    await execAsync(`git push -u origin ${branchName} --force`, { cwd: repoPath });

    // Create PR
    console.log('Creating pull request...');
    const prBody = generatePRBody(session, issue_number);
    
    const { data: pr } = await octokit.pulls.create({
      owner,
      repo,
      title: `ðŸ¤– ${commitTitle}`,
      head: branchName,
      base: 'main', // TODO: make configurable
      body: prBody,
    });

    console.log(`PR created: ${pr.html_url}`);

    // Save PR info to session
    const prMessage: ConversationMessage = {
      role: 'assistant',
      content: `Created PR #${pr.number}: ${pr.html_url}`,
      timestamp: new Date().toISOString(),
      metadata: { phase: 'pr_created', prNumber: pr.number, prUrl: pr.html_url },
    };
    await sessionService.addMessage(session.id, prMessage);
    await sessionService.updateMetadata(session.id, { 
      prNumber: pr.number, 
      prUrl: pr.html_url,
      prBranch: branchName,
    });
    await sessionService.updatePhase(session.id, 'completed');

    // Post success comment
    await githubService.postComment(
      source_repo,
      issue_number,
      `ðŸŽ‰ **Pull Request Created!**\n\n**PR #${pr.number}:** ${pr.html_url}\n\n---\n\n## Summary\n\nThe complete agent workflow has finished:\n\n- âœ… Clarification\n- âœ… Scoping\n- âœ… Design\n- âœ… Planning\n- âœ… Implementation\n- âœ… Testing\n- âœ… PR Created\n\nPlease review the PR and merge when ready! ðŸš€`
    );

    // Update labels
    await githubService.removeLabel(source_repo, issue_number, 'agent:implement');
    await githubService.addLabel(source_repo, issue_number, 'agent:pr-ready');

    return { prNumber: pr.number, prUrl: pr.html_url };

  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    console.error('Failed to create PR:', message);

    await githubService.postComment(
      source_repo,
      issue_number,
      `âŒ **Failed to Create PR**\n\nError: ${message}\n\nYou may need to create the PR manually from the changes.`
    );

    return null;
  }
}

function generatePRBody(session: any, issueNumber: number): string {
  return `## Description

Automated implementation for #${issueNumber}

${session.metadata.issue_body || ''}

---

## Scope

${session.metadata.scope || 'See linked issue for scope details.'}

---

## Technical Design

${session.metadata.design || 'See linked issue for design details.'}

---

## Implementation Plan

${session.metadata.plan || 'See linked issue for implementation plan.'}

---

## Test Results

${session.metadata.testsPassed ? 'âœ… All tests passed' : 'âš ï¸ Some tests may have issues - please review'}

---

## Changed Files

${(session.metadata.implementedFiles as string[] || []).map((f: string) => `- \`${f}\``).join('\n') || 'See Files Changed tab'}

---

> ðŸ¤– This PR was automatically generated by [Cherry Automation](https://github.com/Cherry-Application/cherry-automation)
> 
> Closes #${issueNumber}
`;
}

